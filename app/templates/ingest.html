<!-- app/templates/ingest.html @更新日時: 2025-07-18 17:00 JST -->
{% extends "base.html" %}
{% block content %}

<link rel="stylesheet" href="{{ url_for('static', path='css/ingest.css') }}">

<div id="ingest-container">
  <!-- レイアウト切り替えボタン -->
  <button id="expand-btn" class="layout-toggle-btn" title="PDFプレビューを拡張表示">&lt;&lt;</button>
  <button id="collapse-btn" class="layout-toggle-btn" title="通常表示に戻す">&gt;&gt;</button>

  <!-- 上ペイン -->
  <div id="pane-top">
    <!-- 上ペイン左側（フォーム部分） -->
    <div id="pane-top-left">
      <h1 class="page-title">✏️ データ整形/登録</h1>
      <form id="ingest-form">
        <div class="form-section">
          {% include "partials/ingest/ingest_header.html" %}
        </div>
        <div class="form-section">
          <label for="refine-prompt">📝 整形プロンプト：</label>
          <select id="refine-prompt" name="refine_prompt_key">
            {% for key in prompt_keys %}
            <option value="{{ key }}">{{ key }}</option>
            {% endfor %}
          </select>
          <button type="button" id="prompt-edit-btn" style="margin-left: 0.5em;">確認</button>
          <span style="margin-left: 1em; color: #666; font-size: 0.9em;">（LLM モデル：{{ llm_model }}）</span>
        </div>

        <!-- OCR設定セクション -->
        <div class="form-section">
          <label for="ocr-engine">🔍 OCRエンジン：</label>
          <select id="ocr-engine" name="ocr_engine_id">
            <option value="">デフォルト</option>
          </select>
          <button type="button" id="ocr-settings-btn" style="margin-left: 0.5em;">設定</button>
          <button type="button" id="ocr-presets-btn" style="margin-left: 0.5em;">プリセット</button>
        </div>
        <!-- 省略：埋め込みモデル・上書き・ボタン群 -->
        <div class="form-section">
          <label style="min-width: 140px;">📝 埋め込みモデル：</label>
          {% for key, opt in embedding_options.items() %}
          <label style="margin-left:0.5em;">
            <input type="checkbox" name="embed_models" value="{{ key }}" checked>
            {{ loop.index }}. {{ opt.model_name }}
          </label>
          {% endfor %}
        </div>
        <div class="form-section">
          <label for="overwrite_existing" style="margin-left: 1.5em;">既存レコード上書き：</label>
          <input id="overwrite_existing" type="checkbox" name="overwrite_existing" value="true">
          <label for="quality_threshold">（質スコア閾値</label>
          <input id="quality_threshold" type="number" name="quality_threshold" min="0" max="1" step="0.05" value="0.0"
            style="width:4em;">
          <label>以上はSKIP）</label>
        </div>
        <div class="form-section">
          <label for="llm_timeout">⏱️ LLMタイムアウト：</label>
          <input id="llm_timeout" type="number" name="llm_timeout" min="0" max="3600" step="10" value="300"
            style="width:5em; text-align:center;">
          <label>秒（0でタイムアウトなし）</label>
        </div>
        <div class="form-actions">
          <button type="button" id="start-btn">🚀 処理開始</button>
          <button type="button" id="cancel-btn" disabled>✖️ キャンセル</button>
          <!-- PDF表示モード選択 -->
          <span style="margin-left:1em;">
            PDF表示：<label style="margin-left:0.5em;"><input type="radio" name="pdf_mode" value="embed" checked>
              同一タブ内</label>
            <label style="margin-left:0.5em;"><input type="radio" name="pdf_mode" value="newtab"> 別タブ</label>
          </span>
          <!-- テスト用ボタン -->
          <div style="margin-top: 0.5em;">
            <button type="button" id="test-pdf-btn"
              style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer;">テスト用PDF表示</button>
            <button type="button" id="debug-layout-btn"
              style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-left: 5px;">レイアウトデバッグ</button>
          </div>
        </div>
      </form>
    </div>

    <!-- 上ペイン右側（PDFプレビュー用） -->
    <div id="pane-top-right">
      <div id="pdf-preview-area">
        <iframe id="pdf-preview-frame" style="width: 100%; height: 100%; border: none;"></iframe>
      </div>
    </div>
  </div>

  <!-- 下ペイン：ログ and 編集 -->
  <div id="pane-bottom">
    <div id="log-pane"></div>

    <!-- ログペインと編集ペインの間に可変スプリッター -->
    <div id="splitter"></div>
    <div id="editor-pane">
      <textarea id="prompt-editor"></textarea>
    </div>
  </div>

</div>

<!-- 拡張モード用PDFプレビューエリア（画面右側全体） -->
<div id="splitter-expanded"></div>
<div id="pdf-preview-expanded">
  <iframe id="pdf-preview-frame-expanded" style="width: 100%; height: 100%; border: none;"></iframe>
</div>

<!-- 処理中のナビゲーション警告 -->
<div id="nav-warning">
  ⚠️ データ処理中です<br>
  他のページへの移動はできません<br>
  <small>キャンセルボタンで処理を中止できます</small>
</div>

<!-- OCR設定モーダル -->
<div id="ocr-settings-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>🔍 OCR設定</h3>
      <span class="close" id="ocr-settings-close">&times;</span>
    </div>
    <div id="ocr-settings-content">
      <!-- 動的に生成される設定項目 -->
    </div>
    <div class="modal-actions">
      <button type="button" class="btn-secondary" id="ocr-settings-cancel">キャンセル</button>
      <button type="button" class="btn-primary" id="ocr-settings-save">保存</button>
    </div>
  </div>
</div>

<!-- OCRプリセットモーダル -->
<div id="ocr-presets-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>📋 OCRプリセット</h3>
      <span class="close" id="ocr-presets-close">&times;</span>
    </div>
    <div style="margin-bottom: 15px;">
      <input type="text" id="new-preset-name" placeholder="新しいプリセット名" style="width: 70%; margin-right: 10px;">
      <button type="button" class="btn-primary" id="save-current-preset">現在の設定を保存</button>
    </div>
    <div id="ocr-presets-list">
      <!-- 動的に生成されるプリセット一覧 -->
    </div>
    <div class="modal-actions">
      <button type="button" class="btn-secondary" id="ocr-presets-cancel">閉じる</button>
    </div>
  </div>
</div>

<!-- REM: スクリプト読み込み（バージョン管理付き） -->
<script src="{{ url_for('static', path='js/ingest.js') }}?v=20250718"></script>
<script src="{{ url_for('static', path='js/ingest_sse.js') }}?v=20250722"></script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    let processingInProgress = false;
    const navWarning = document.getElementById('nav-warning');

    // 処理開始時の制御
    function startProcessing() {
      processingInProgress = true;
      document.body.classList.add('processing-in-progress');

      // ページ離脱の警告
      window.addEventListener('beforeunload', handleBeforeUnload);

      // ナビゲーションリンクのクリックを監視
      document.querySelectorAll('nav a').forEach(link => {
        link.addEventListener('click', handleNavClick);
      });
    }

    // 処理終了時の制御
    function endProcessing() {
      processingInProgress = false;
      document.body.classList.remove('processing-in-progress');

      // イベントリスナーを削除
      window.removeEventListener('beforeunload', handleBeforeUnload);
      document.querySelectorAll('nav a').forEach(link => {
        link.removeEventListener('click', handleNavClick);
      });

      // 警告メッセージを隠す
      navWarning.style.display = 'none';
    }

    // ページ離脱時の警告
    function handleBeforeUnload(e) {
      if (processingInProgress) {
        const message = 'データ処理中です。ページを離れると処理が中断されます。';
        e.preventDefault();
        e.returnValue = message;
        return message;
      }
    }

    // ナビゲーションリンククリック時の処理
    function handleNavClick(e) {
      if (processingInProgress) {
        e.preventDefault();
        e.stopPropagation();

        // 警告メッセージを表示
        navWarning.style.display = 'block';

        // 3秒後に自動で隠す
        setTimeout(() => {
          navWarning.style.display = 'none';
        }, 3000);

        return false;
      }
    }

    // 処理開始ボタンのイベントリスナー（既存のJavaScriptと連携）
    const startBtn = document.getElementById('start-btn');
    const cancelBtn = document.getElementById('cancel-btn');

    if (startBtn) {
      startBtn.addEventListener('click', function () {
        // 処理開始の制御を追加
        startProcessing();
      });
    }

    if (cancelBtn) {
      cancelBtn.addEventListener('click', function () {
        // キャンセル時の制御を追加
        endProcessing();
      });
    }

    // 処理完了時の制御（既存のJavaScriptから呼び出される想定）
    window.onIngestComplete = function () {
      endProcessing();
    };

    // 処理エラー時の制御（既存のJavaScriptから呼び出される想定）
    window.ingestProcessError = function () {
      endProcessing();
    };

    // OCR機能の初期化
    initOCRFeatures();

    // レイアウト切り替え機能の初期化
    initLayoutToggle();

    // リサイズ機能の初期化
    initResizeHandlers();
  });

  // レイアウト切り替え機能の初期化
  function initLayoutToggle() {
    const expandBtn = document.getElementById('expand-btn');
    const collapseBtn = document.getElementById('collapse-btn');
    const container = document.getElementById('ingest-container');
    const pdfPreviewFrameExpanded = document.getElementById('pdf-preview-frame-expanded');

    let currentPdfUrl = null;
    let layoutState = 'no-preview'; // 'no-preview', 'preview-normal', 'preview-expanded'

    // レイアウト状態を更新する関数
    function updateLayoutState(newState) {
      console.log(`レイアウト状態変更: ${layoutState} → ${newState}`);

      // 既存のクラスを削除
      document.body.classList.remove('layout-preview-normal', 'layout-expanded');

      // 新しい状態に応じてクラスを追加
      switch (newState) {
        case 'preview-normal':
          document.body.classList.add('layout-preview-normal');
          break;
        case 'preview-expanded':
          document.body.classList.add('layout-expanded');
          break;
        case 'no-preview':
        default:
          // クラスなし（デフォルト状態）
          break;
      }

      layoutState = newState;
    }

    // 拡張ボタンのクリックイベント（第1パターン → 第2パターン）
    expandBtn.addEventListener('click', function () {
      console.log('拡張ボタンクリック - 第2パターンに切り替え');

      if (layoutState === 'preview-normal') {
        // リサイズ設定をリセット
        if (window.resetResizeSettings) {
          window.resetResizeSettings();
        }

        updateLayoutState('preview-expanded');

        // PDFが表示されている場合は、拡張プレビューエリアに表示
        if (currentPdfUrl) {
          console.log('PDFを拡張プレビューエリアに表示:', currentPdfUrl);
          pdfPreviewFrameExpanded.src = currentPdfUrl;
        }
      }
    });

    // 縮小ボタンのクリックイベント（第2パターン → 第1パターン）
    collapseBtn.addEventListener('click', function () {
      console.log('縮小ボタンクリック - 第1パターンに切り替え');

      if (layoutState === 'preview-expanded') {
        // リサイズ設定をリセット
        if (window.resetResizeSettings) {
          window.resetResizeSettings();
        }

        updateLayoutState('preview-normal');

        // 拡張プレビューエリアをクリア
        pdfPreviewFrameExpanded.src = '';

        // 通常プレビューエリアに表示
        if (currentPdfUrl) {
          const pdfPreviewFrame = document.getElementById('pdf-preview-frame');
          pdfPreviewFrame.src = currentPdfUrl;
        }
      }
    });

    // PDFプレビュー表示関数をグローバルに公開
    window.showPdfPreview = function (pdfUrl) {
      console.log('showPdfPreview呼び出し:', pdfUrl);
      currentPdfUrl = pdfUrl;

      // プレビューなし状態の場合は第1パターンに遷移
      if (layoutState === 'no-preview') {
        updateLayoutState('preview-normal');
      }

      if (layoutState === 'preview-expanded') {
        // 第2パターン：拡張プレビューエリアに表示
        console.log('第2パターンでPDF表示:', pdfUrl);
        pdfPreviewFrameExpanded.src = pdfUrl;
      } else if (layoutState === 'preview-normal') {
        // 第1パターン：editor-pane内にiframeを作成してPDF表示
        console.log('第1パターンでPDF表示:', pdfUrl);
        const editorPane = document.getElementById('editor-pane');

        // 既存のtextareaを隠す
        const textarea = editorPane.querySelector('textarea');
        if (textarea) {
          textarea.style.display = 'none';
        }

        // PDF用のiframeを作成または更新
        let pdfIframe = editorPane.querySelector('#pdf-iframe-pattern1');
        if (!pdfIframe) {
          pdfIframe = document.createElement('iframe');
          pdfIframe.id = 'pdf-iframe-pattern1';
          pdfIframe.style.width = '100%';
          pdfIframe.style.height = '100%';
          pdfIframe.style.border = 'none';
          editorPane.appendChild(pdfIframe);
        }

        pdfIframe.src = pdfUrl;
      }
    };

    // PDFプレビュー非表示関数をグローバルに公開
    window.hidePdfPreview = function () {
      console.log('PDFプレビュー非表示 - プレビューなし状態に遷移');
      currentPdfUrl = null;

      // プレビューなし状態に遷移
      updateLayoutState('no-preview');

      // 全てのプレビューエリアをクリア
      pdfPreviewFrameExpanded.src = '';
      const pdfPreviewFrame = document.getElementById('pdf-preview-frame');
      if (pdfPreviewFrame) {
        pdfPreviewFrame.src = '';
      }
    };

    // ファイル番号リンクのクリックイベントを監視
    function attachFileNumberClickHandlers() {
      // ログペイン内のファイル番号リンクを監視
      const logPane = document.getElementById('log-pane');
      if (logPane) {
        logPane.addEventListener('click', function (event) {
          const target = event.target;

          // ファイル番号のリンクかどうかを判定
          if (target.tagName === 'A' && target.textContent.match(/^\d+$/)) {
            console.log('ファイル番号リンクがクリックされました:', target.textContent);

            // PDFプレビューを非表示にしてプレビューなし状態に戻す
            window.hidePdfPreview();

            // デフォルトのリンク動作は継続
          }
        });
      }
    }

    // ページ読み込み時とログ更新時にファイル番号リンクのハンドラーを設定
    attachFileNumberClickHandlers();

    // MutationObserverでログペインの変更を監視
    const logPane = document.getElementById('log-pane');
    if (logPane) {
      const observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          if (mutation.type === 'childList') {
            // 新しいファイル番号リンクが追加された可能性があるので再設定
            attachFileNumberClickHandlers();
          }
        });
      });

      observer.observe(logPane, {
        childList: true,
        subtree: true
      });
    }
  }

  // OCR機能の初期化
  function initOCRFeatures() {
    let availableEngines = {};
    let currentEngineSettings = {};

    // ページ読み込み時にOCRエンジン一覧を取得
    loadOCREngines();

    // OCRエンジン選択の変更イベント
    document.getElementById('ocr-engine').addEventListener('change', function () {
      const engineId = this.value;
      if (engineId) {
        loadEngineSettings(engineId);
      }
    });

    // OCR設定ボタンのクリックイベント
    document.getElementById('ocr-settings-btn').addEventListener('click', function () {
      const engineId = document.getElementById('ocr-engine').value;
      if (!engineId) {
        alert('OCRエンジンを選択してください');
        return;
      }
      showOCRSettingsModal(engineId);
    });

    // OCRプリセットボタンのクリックイベント
    document.getElementById('ocr-presets-btn').addEventListener('click', function () {
      showOCRPresetsModal();
    });

    // モーダルの閉じるボタンイベント
    document.getElementById('ocr-settings-close').addEventListener('click', closeOCRSettingsModal);
    document.getElementById('ocr-settings-cancel').addEventListener('click', closeOCRSettingsModal);
    document.getElementById('ocr-presets-close').addEventListener('click', closeOCRPresetsModal);
    document.getElementById('ocr-presets-cancel').addEventListener('click', closeOCRPresetsModal);

    // OCR設定保存ボタンイベント
    document.getElementById('ocr-settings-save').addEventListener('click', saveOCRSettings);

    // プリセット保存ボタンイベント
    document.getElementById('save-current-preset').addEventListener('click', saveCurrentPreset);

    // モーダル外クリックで閉じる
    window.addEventListener('click', function (event) {
      const settingsModal = document.getElementById('ocr-settings-modal');
      const presetsModal = document.getElementById('ocr-presets-modal');
      if (event.target === settingsModal) {
        closeOCRSettingsModal();
      }
      if (event.target === presetsModal) {
        closeOCRPresetsModal();
      }
    });

    // OCRエンジン一覧を読み込み
    async function loadOCREngines() {
      try {
        const response = await fetch('/ingest/ocr/engines');
        availableEngines = await response.json();

        const select = document.getElementById('ocr-engine');
        select.innerHTML = '<option value="">デフォルト</option>';

        for (const [engineId, engineInfo] of Object.entries(availableEngines)) {
          const option = document.createElement('option');
          option.value = engineId;
          option.textContent = `${engineInfo.name} ${engineInfo.available ? '✓' : '✗'}`;
          option.disabled = !engineInfo.available;
          select.appendChild(option);
        }
      } catch (error) {
        console.error('OCRエンジン一覧の読み込みに失敗:', error);
      }
    }

    // エンジン設定を読み込み
    async function loadEngineSettings(engineId) {
      try {
        const response = await fetch(`/ingest/ocr/settings/${engineId}`);
        const data = await response.json();
        currentEngineSettings = data.settings;
      } catch (error) {
        console.error('エンジン設定の読み込みに失敗:', error);
        currentEngineSettings = {};
      }
    }

    // OCR設定モーダルを表示
    function showOCRSettingsModal(engineId) {
      const modal = document.getElementById('ocr-settings-modal');
      const content = document.getElementById('ocr-settings-content');

      if (!availableEngines[engineId]) {
        alert('エンジン情報が見つかりません');
        return;
      }

      const engineInfo = availableEngines[engineId];
      const parameters = engineInfo.parameters || [];

      // 設定項目を動的生成
      content.innerHTML = '';

      if (parameters.length === 0) {
        content.innerHTML = '<p>このエンジンには設定可能なパラメータがありません。</p>';
      } else {
        parameters.forEach(param => {
          const group = document.createElement('div');
          group.className = 'ocr-setting-group';

          const label = document.createElement('label');
          label.textContent = param.label;
          group.appendChild(label);

          let input;
          const currentValue = currentEngineSettings[param.name] !== undefined
            ? currentEngineSettings[param.name]
            : param.default;

          if (param.type === 'checkbox') {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = currentValue;
          } else if (param.type === 'number') {
            input = document.createElement('input');
            input.type = 'number';
            input.value = currentValue;
            if (param.min !== undefined) input.min = param.min;
            if (param.max !== undefined) input.max = param.max;
            if (param.step !== undefined) input.step = param.step;
          } else if (param.type === 'select') {
            input = document.createElement('select');
            param.options.forEach(option => {
              const opt = document.createElement('option');
              opt.value = option.value;
              opt.textContent = option.label;
              opt.selected = option.value === currentValue;
              input.appendChild(opt);
            });
          } else {
            input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue;
          }

          input.dataset.paramName = param.name;
          group.appendChild(input);

          if (param.description) {
            const desc = document.createElement('div');
            desc.className = 'ocr-setting-description';
            desc.textContent = param.description;
            group.appendChild(desc);
          }

          content.appendChild(group);
        });
      }

      modal.style.display = 'block';
    }

    // OCR設定モーダルを閉じる
    function closeOCRSettingsModal() {
      document.getElementById('ocr-settings-modal').style.display = 'none';
    }

    // OCRプリセットモーダルを表示
    async function showOCRPresetsModal() {
      const modal = document.getElementById('ocr-presets-modal');
      const list = document.getElementById('ocr-presets-list');

      try {
        const response = await fetch('/ingest/ocr/presets');
        const presets = await response.json();

        list.innerHTML = '';

        if (Object.keys(presets).length === 0) {
          list.innerHTML = '<p>保存されたプリセットがありません。</p>';
        } else {
          for (const [presetName, presetData] of Object.entries(presets)) {
            const item = document.createElement('div');
            item.className = 'preset-item';

            const info = document.createElement('div');
            info.className = 'preset-info';

            const name = document.createElement('div');
            name.className = 'preset-name';
            name.textContent = presetName;
            info.appendChild(name);

            const details = document.createElement('div');
            details.className = 'preset-details';
            details.textContent = `エンジン: ${presetData.engine} | 作成日: ${new Date(presetData.created_at).toLocaleDateString()}`;
            info.appendChild(details);

            item.appendChild(info);

            const actions = document.createElement('div');

            const loadBtn = document.createElement('button');
            loadBtn.textContent = '読み込み';
            loadBtn.className = 'btn-primary';
            loadBtn.style.marginRight = '5px';
            loadBtn.addEventListener('click', () => loadPreset(presetName, presetData));
            actions.appendChild(loadBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '削除';
            deleteBtn.className = 'btn-secondary';
            deleteBtn.addEventListener('click', () => deletePreset(presetName));
            actions.appendChild(deleteBtn);

            item.appendChild(actions);
            list.appendChild(item);
          }
        }

        modal.style.display = 'block';
      } catch (error) {
        console.error('プリセット一覧の読み込みに失敗:', error);
        alert('プリセット一覧の読み込みに失敗しました');
      }
    }

    // OCRプリセットモーダルを閉じる
    function closeOCRPresetsModal() {
      document.getElementById('ocr-presets-modal').style.display = 'none';
    }

    // OCR設定を保存
    async function saveOCRSettings() {
      const engineId = document.getElementById('ocr-engine').value;
      if (!engineId) return;

      const settings = {};
      const inputs = document.querySelectorAll('#ocr-settings-content input, #ocr-settings-content select');

      inputs.forEach(input => {
        const paramName = input.dataset.paramName;
        if (paramName) {
          if (input.type === 'checkbox') {
            settings[paramName] = input.checked;
          } else if (input.type === 'number') {
            settings[paramName] = parseFloat(input.value);
          } else {
            settings[paramName] = input.value;
          }
        }
      });

      try {
        const response = await fetch(`/ingest/ocr/settings/${engineId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(settings)
        });

        if (response.ok) {
          currentEngineSettings = settings;
          alert('設定を保存しました');
          closeOCRSettingsModal();
        } else {
          alert('設定の保存に失敗しました');
        }
      } catch (error) {
        console.error('設定保存エラー:', error);
        alert('設定の保存に失敗しました');
      }
    }

    // 現在の設定をプリセットとして保存
    async function saveCurrentPreset() {
      const presetName = document.getElementById('new-preset-name').value.trim();
      const engineId = document.getElementById('ocr-engine').value;

      if (!presetName) {
        alert('プリセット名を入力してください');
        return;
      }

      if (!engineId) {
        alert('OCRエンジンを選択してください');
        return;
      }

      try {
        const response = await fetch('/ingest/ocr/presets', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            preset_name: presetName,
            engine_id: engineId,
            settings: currentEngineSettings
          })
        });

        if (response.ok) {
          alert('プリセットを保存しました');
          document.getElementById('new-preset-name').value = '';
          showOCRPresetsModal(); // リストを更新
        } else {
          alert('プリセットの保存に失敗しました');
        }
      } catch (error) {
        console.error('プリセット保存エラー:', error);
        alert('プリセットの保存に失敗しました');
      }
    }

    // プリセットを読み込み
    function loadPreset(presetName, presetData) {
      document.getElementById('ocr-engine').value = presetData.engine;
      currentEngineSettings = presetData.settings;
      alert(`プリセット "${presetName}" を読み込みました`);
      closeOCRPresetsModal();
    }

    // プリセットを削除
    async function deletePreset(presetName) {
      if (!confirm(`プリセット "${presetName}" を削除しますか？`)) {
        return;
      }

      try {
        const response = await fetch(`/ingest/ocr/presets/${encodeURIComponent(presetName)}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          alert('プリセットを削除しました');
          showOCRPresetsModal(); // リストを更新
        } else {
          alert('プリセットの削除に失敗しました');
        }
      } catch (error) {
        console.error('プリセット削除エラー:', error);
        alert('プリセットの削除に失敗しました');
      }
    }

    // フォーム送信時にOCR設定を含める
    const originalStartBtn = document.getElementById('start-btn');
    if (originalStartBtn) {
      originalStartBtn.addEventListener('click', function () {
        // OCR設定をフォームに追加
        const form = document.getElementById('ingest-form');

        // 既存のOCR設定フィールドを削除
        const existingOCRSettings = form.querySelector('input[name="ocr_settings"]');
        if (existingOCRSettings) {
          existingOCRSettings.remove();
        }

        // OCR設定を追加
        const ocrSettingsInput = document.createElement('input');
        ocrSettingsInput.type = 'hidden';
        ocrSettingsInput.name = 'ocr_settings';
        ocrSettingsInput.value = JSON.stringify(currentEngineSettings);
        form.appendChild(ocrSettingsInput);
      });
    }

    // テスト用ボタンとデバッグボタンのイベントリスナー
    const testPdfBtn = document.getElementById('test-pdf-btn');
    const debugLayoutBtn = document.getElementById('debug-layout-btn');

    if (testPdfBtn) {
      testPdfBtn.addEventListener('click', function () {
        console.log('テスト用PDFボタンがクリックされました');

        // 簡単なテスト用PDF（最小限のPDFデータ）
        const testPdfUrl = 'data:application/pdf;base64,JVBERi0xLjQKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjIgMCBvYmoKPDwKL1R5cGUgL1BhZ2VzCi9LaWRzIFszIDAgUl0KL0NvdW50IDEKPD4KZW5kb2JqCjMgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL1BhcmVudCAyIDAgUgovTWVkaWFCb3ggWzAgMCA2MTIgNzkyXQovUmVzb3VyY2VzIDw8Ci9Gb250IDw8Ci9GMSA0IDAgUgo+Pgo+PgovQ29udGVudHMgNSAwIFIKPj4KZW5kb2JqCjQgMCBvYmoKPDwKL1R5cGUgL0ZvbnQKL1N1YnR5cGUgL1R5cGUxCi9CYXNlRm9udCAvSGVsdmV0aWNhCj4+CmVuZG9iago1IDAgb2JqCjw8Ci9MZW5ndGggNDQKPj4Kc3RyZWFtCkJUCi9GMSAxMiBUZgoxMDAgNzAwIFRkCihUZXN0IFBERikgVGoKRVQKZW5kc3RyZWFtCmVuZG9iagp4cmVmCjAgNgowMDAwMDAwMDAwIDY1NTM1IGYgCjAwMDAwMDAwMDkgMDAwMDAgbiAKMDAwMDAwMDA1OCAwMDAwMCBuIAowMDAwMDAwMTE1IDAwMDAwIG4gCjAwMDAwMDAyNDUgMDAwMDAgbiAKMDAwMDAwMDMxNCAwMDAwMCBuIAp0cmFpbGVyCjw8Ci9TaXplIDYKL1Jvb3QgMSAwIFIKPj4Kc3RhcnR4cmVmCjQwOAolJUVPRg==';

        console.log('PDFプレビュー表示を試行:', testPdfUrl.substring(0, 50) + '...');

        // PDFプレビュー表示関数を呼び出し
        if (window.showPdfPreview) {
          window.showPdfPreview(testPdfUrl);
          console.log('showPdfPreview関数を呼び出しました');
        } else {
          console.error('showPdfPreview関数が見つかりません');
          alert('showPdfPreview関数が見つかりません');
        }
      });
    }

    if (debugLayoutBtn) {
      debugLayoutBtn.addEventListener('click', function () {
        console.log('=== レイアウトデバッグ情報 ===');

        const main = document.querySelector('main');
        const ingestContainer = document.getElementById('ingest-container');
        const pdfExpanded = document.getElementById('pdf-preview-expanded');

        console.log('main要素:', main);
        console.log('main要素のスタイル:', window.getComputedStyle(main));
        console.log('main要素のdisplay:', window.getComputedStyle(main).display);
        console.log('main要素のflex-direction:', window.getComputedStyle(main).flexDirection);

        console.log('ingest-container要素:', ingestContainer);
        console.log('ingest-container要素のflex:', window.getComputedStyle(ingestContainer).flex);

        console.log('pdf-preview-expanded要素:', pdfExpanded);
        console.log('pdf-preview-expanded要素のdisplay:', window.getComputedStyle(pdfExpanded).display);
        console.log('pdf-preview-expanded要素のflex:', window.getComputedStyle(pdfExpanded).flex);

        console.log('body要素のクラス:', document.body.className);
        console.log('layout-expandedクラスが適用されているか:', document.body.classList.contains('layout-expanded'));

        alert('デバッグ情報をコンソールに出力しました。F12キーでコンソールを確認してください。');
      });
    }
  }

  // リサイズ機能の初期化
  function initResizeHandlers() {
    let isResizing = false;
    let currentSplitter = null;
    let startX = 0;
    let containerWidth = 0;

    // 第1パターン用のリサイズ処理
    const splitter = document.getElementById('splitter');
    const logPane = document.getElementById('log-pane');
    const editorPane = document.getElementById('editor-pane');

    // 第2パターン用のリサイズ処理
    const splitterExpanded = document.getElementById('splitter-expanded');
    const ingestContainer = document.getElementById('ingest-container');
    const pdfPreviewExpanded = document.getElementById('pdf-preview-expanded');

    // 第1パターンのスプリッター
    if (splitter) {
      splitter.addEventListener('mousedown', function (e) {
        console.log('第1パターンのスプリッターがクリックされました');

        // 現在のレイアウト状態を確認
        if (!document.body.classList.contains('layout-preview-normal')) {
          console.log('第1パターンではないため、リサイズを無効化');
          return;
        }

        isResizing = true;
        currentSplitter = 'normal';
        startX = e.clientX;

        const paneBottom = document.getElementById('pane-bottom');
        containerWidth = paneBottom.getBoundingClientRect().width - 5; // スプリッター幅を除く

        // 既存のスタイルをクリア
        logPane.style.width = '';
        logPane.style.flex = '';
        editorPane.style.width = '';
        editorPane.style.flex = '';

        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
        e.stopPropagation();

        console.log(`第1パターンリサイズ開始: コンテナ幅=${containerWidth}px`);
      });
    }

    // 第2パターンのスプリッター
    if (splitterExpanded) {
      splitterExpanded.addEventListener('mousedown', function (e) {
        console.log('第2パターンのスプリッターがクリックされました');

        // 現在のレイアウト状態を確認
        if (!document.body.classList.contains('layout-expanded')) {
          console.log('第2パターンではないため、リサイズを無効化');
          return;
        }

        isResizing = true;
        currentSplitter = 'expanded';
        startX = e.clientX;

        const mainRect = document.querySelector('main').getBoundingClientRect();
        containerWidth = mainRect.width - 5; // スプリッター幅を除く

        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
        e.stopPropagation();

        console.log(`第2パターンリサイズ開始: コンテナ幅=${containerWidth}px`);
      });
    }

    // マウス移動時の処理
    document.addEventListener('mousemove', function (e) {
      if (!isResizing) return;

      const currentX = e.clientX;
      const deltaX = currentX - startX;

      if (currentSplitter === 'normal') {
        // 第1パターンのリサイズ処理
        // 現在のマウス位置から左側の幅を計算
        const paneBottom = document.getElementById('pane-bottom');
        const paneRect = paneBottom.getBoundingClientRect();
        const leftWidth = currentX - paneRect.left;
        const rightWidth = paneRect.right - currentX - 5; // スプリッター幅を除く

        // 最小幅の制限（20%）
        const minWidth = containerWidth * 0.2;
        if (leftWidth >= minWidth && rightWidth >= minWidth) {
          const leftPercentage = (leftWidth / containerWidth) * 100;
          const rightPercentage = (rightWidth / containerWidth) * 100;

          // resizingクラスを追加してCSSの競合を回避
          logPane.classList.add('resizing');
          editorPane.classList.add('resizing');

          // widthプロパティを直接設定
          logPane.style.width = `${leftPercentage}%`;
          editorPane.style.width = `${rightPercentage}%`;

          console.log(`第1パターンリサイズ: 左=${leftPercentage.toFixed(1)}%, 右=${rightPercentage.toFixed(1)}%`);
        }
      } else if (currentSplitter === 'expanded') {
        // 第2パターンのリサイズ処理
        const mainRect = document.querySelector('main').getBoundingClientRect();
        const leftWidth = currentX - mainRect.left;
        const rightWidth = mainRect.right - currentX - 5; // スプリッター幅を除く

        // 最小幅の制限（20%）
        const minWidth = containerWidth * 0.2;
        if (leftWidth >= minWidth && rightWidth >= minWidth) {
          const leftPercentage = (leftWidth / containerWidth) * 100;
          const rightPercentage = (rightWidth / containerWidth) * 100;

          // resizingクラスを追加してCSSの競合を回避
          ingestContainer.classList.add('resizing');
          pdfPreviewExpanded.classList.add('resizing');

          // widthプロパティを直接設定
          ingestContainer.style.width = `${leftPercentage}%`;
          pdfPreviewExpanded.style.width = `${rightPercentage}%`;

          console.log(`第2パターンリサイズ: 左=${leftPercentage.toFixed(1)}%, 右=${rightPercentage.toFixed(1)}%`);
        }
      }
    });

    // マウスアップ時の処理
    document.addEventListener('mouseup', function () {
      if (isResizing) {
        console.log('リサイズ終了');
        isResizing = false;
        currentSplitter = null;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }
    });

    // ウィンドウからマウスが出た時の処理
    document.addEventListener('mouseleave', function () {
      if (isResizing) {
        console.log('マウスがウィンドウから出たため、リサイズ終了');
        isResizing = false;
        currentSplitter = null;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }
    });

    // レイアウト切り替え時にリサイズ設定をリセット
    function resetResizeSettings() {
      // 第1パターンのリセット
      logPane.style.width = '';
      logPane.style.flex = '';
      logPane.classList.remove('resizing');
      editorPane.style.width = '';
      editorPane.style.flex = '';
      editorPane.classList.remove('resizing');

      // 第2パターンのリセット
      ingestContainer.style.width = '';
      ingestContainer.style.flex = '';
      ingestContainer.classList.remove('resizing');
      pdfPreviewExpanded.style.width = '';
      pdfPreviewExpanded.style.flex = '';
      pdfPreviewExpanded.classList.remove('resizing');

      console.log('リサイズ設定をリセットしました');
    }

    // レイアウト切り替え時にリセット関数を呼び出せるようにグローバルに公開
    window.resetResizeSettings = resetResizeSettings;
  }
</script>

{% endblock %}